{"ast":null,"code":"import { TOP_DELEGATES, PROPOSALS, GLOBAL_DATA, DELEGATES_FROM_LIST, TOP_DELEGATES_OFFSET } from '../apollo/queries';\nimport { ethers } from 'ethers';\nimport { fetchProfileData } from './social';\nimport { isAddress } from '../utils';\nimport { PRELOADED_PROPOSALS } from '../constants';\nimport { AUTONOMOUS_PROPOSAL_BYTECODE } from '../constants/proposals';\nexport async function fetchGlobalData(client) {\n  if (!client) {\n    return null;\n  }\n\n  return client.query({\n    query: GLOBAL_DATA,\n    fetchPolicy: 'cache-first'\n  }).then(async res => {\n    if (res) {\n      return {\n        id: res.data.governances[0].id,\n        delegatedVotes: parseInt(res.data.governances[0].delegatedVotes),\n        delegatedVotesRaw: parseInt(res.data.governances[0].delegatedVotesRaw),\n        totalTokenHolders: parseInt(res.data.governances[0].totalTokenHolders),\n        totalDelegates: parseInt(res.data.governances[0].totalDelegates)\n      };\n    } else {\n      return Promise.reject('Error fetching global data');\n    }\n  }).catch(() => {\n    return Promise.reject('Error fetching from subgraph');\n  });\n}\n\nasync function fetchDelegatesFromClient(client, library, allIdentities, query) {\n  try {\n    return client.query(query).then(async res => {\n      // check if account is EOA or not\n      const typed = await Promise.all(res.data.delegates.map(d => {\n        return library === null || library === void 0 ? void 0 : library.getCode(d.id);\n      })); // for each handle - get twitter profile data ,\n\n      const handles = await Promise.all(res.data.delegates.map(async a => {\n        var _allIdentities$checks, _allIdentities$checks2, _profileData, _profileData$data;\n\n        const checksummed = isAddress(a.id);\n        const handle = checksummed ? allIdentities === null || allIdentities === void 0 ? void 0 : (_allIdentities$checks = allIdentities[checksummed]) === null || _allIdentities$checks === void 0 ? void 0 : (_allIdentities$checks2 = _allIdentities$checks.twitter) === null || _allIdentities$checks2 === void 0 ? void 0 : _allIdentities$checks2.handle : undefined;\n        let profileData;\n\n        try {\n          if (handle) {\n            const res = await fetchProfileData(handle);\n\n            if (res) {\n              profileData = res;\n            }\n          }\n        } catch (e) {\n          profileData = undefined;\n        }\n\n        return {\n          account: a.id,\n          handle,\n          imageURL: (_profileData = profileData) === null || _profileData === void 0 ? void 0 : (_profileData$data = _profileData.data) === null || _profileData$data === void 0 ? void 0 : _profileData$data.profile_image_url\n        };\n      }));\n      return res.data.delegates.map((d, i) => {\n        var _handles$find, _handles$find2;\n\n        const checksummed = isAddress(d.id);\n\n        if (checksummed) {\n          d.id = checksummed;\n        }\n\n        return { ...d,\n          EOA: typed[i] === '0x',\n          autonomous: typed[i] === AUTONOMOUS_PROPOSAL_BYTECODE,\n          handle: (_handles$find = handles.find(h => h.account.toLowerCase() === d.id.toLowerCase())) === null || _handles$find === void 0 ? void 0 : _handles$find.handle,\n          imageURL: (_handles$find2 = handles.find(h => h.account.toLowerCase() === d.id.toLowerCase())) === null || _handles$find2 === void 0 ? void 0 : _handles$find2.imageURL\n        };\n      });\n    }).catch(e => {\n      return Promise.reject(`Error fetching delegates from subgraph: ${e.message}`);\n    });\n  } catch (e) {\n    return Promise.reject('Unable to fetch delegates');\n  }\n}\n\nexport async function fetchTopDelegates(client, library, allIdentities) {\n  return fetchDelegatesFromClient(client, library, allIdentities, {\n    query: TOP_DELEGATES,\n    fetchPolicy: 'cache-first'\n  });\n}\nexport async function fetchTopDelegatesOffset(client, library, allIdentities, maxFetched) {\n  return fetchDelegatesFromClient(client, library, allIdentities, {\n    query: TOP_DELEGATES_OFFSET,\n    variables: {\n      skip: maxFetched\n    },\n    fetchPolicy: 'cache-first'\n  });\n}\n/**\n * Used for filtering on verified entries only\n */\n\nexport async function fetchVerifiedDelegates(client, library, allIdentities) {\n  var _Object$keys;\n\n  return fetchDelegatesFromClient(client, library, allIdentities, {\n    query: DELEGATES_FROM_LIST,\n    variables: {\n      // filter on address - graph needs lowercase\n      list: allIdentities && ((_Object$keys = Object.keys(allIdentities)) === null || _Object$keys === void 0 ? void 0 : _Object$keys.map(a => a.toLocaleLowerCase()))\n    },\n    fetchPolicy: 'cache-first'\n  });\n}\n/**\n * @todo replace with auto generated grapql format\n */\n\nexport const enumerateProposalState = state => {\n  const proposalStates = ['pending', 'active', 'canceled', 'defeated', 'succeeded', 'queued', 'expired', 'executed'];\n  return proposalStates[state];\n}; // @todo add typed query response\n\nconst PROPOSAL_PROMISES = {};\nexport async function fetchProposals(client, key, govId) {\n  var _PROPOSAL_PROMISES$ke;\n\n  return (PROPOSAL_PROMISES[key] = (_PROPOSAL_PROMISES$ke = PROPOSAL_PROMISES[key]) !== null && _PROPOSAL_PROMISES$ke !== void 0 ? _PROPOSAL_PROMISES$ke : client.query({\n    query: PROPOSALS,\n    fetchPolicy: 'cache-first'\n  }).then(async res => {\n    if (res) {\n      return res.data.proposals.map((p, i) => {\n        var _PRELOADED_PROPOSALS$, _description;\n\n        let description = ((_PRELOADED_PROPOSALS$ = PRELOADED_PROPOSALS[govId]) === null || _PRELOADED_PROPOSALS$ === void 0 ? void 0 : _PRELOADED_PROPOSALS$[res.data.proposals.length - i - 1]) || p.description;\n        console.log(p.startBlock);\n\n        if (p.startBlock === '13551293') {\n          description = description.replace(/  /g, '\\n').replace(/\\d\\. /g, '\\n$&');\n        }\n\n        return {\n          id: p.id,\n          title: ((_description = description) === null || _description === void 0 ? void 0 : _description.split(/# |\\n/g)[1]) || 'Untitled',\n          description: description || 'No description.',\n          proposer: p.proposer.id,\n          status: undefined,\n          // initialize as 0\n          forCount: undefined,\n          // initialize as 0\n          againstCount: undefined,\n          // initialize as 0\n          startBlock: parseInt(p.startBlock),\n          endBlock: parseInt(p.endBlock),\n          forVotes: p.forVotes,\n          againstVotes: p.againstVotes,\n          details: p.targets.map((t, i) => {\n            let name = '',\n                types = '',\n                callData = '';\n            const signature = p.signatures[i];\n\n            if (signature) {\n              const sigSplit = signature.substr(0, signature.length - 1).split('(');\n              name = sigSplit[0];\n              types = sigSplit[1];\n            }\n\n            const calldata = p.calldatas[i];\n\n            if (calldata && types) {\n              const decoded = ethers.utils.defaultAbiCoder.decode(types.split(','), calldata);\n              callData = decoded.toString();\n            }\n\n            return {\n              target: p.targets[i],\n              functionSig: name,\n              callData\n            };\n          })\n        };\n      });\n    }\n\n    return null;\n  })).catch(() => {\n    return Promise.reject('Error fetching proposals from subgraph');\n  });\n}","map":{"version":3,"sources":["/Users/safahi/Documents/GitHub/sybil-interf/src/data/governance.ts"],"names":["TOP_DELEGATES","PROPOSALS","GLOBAL_DATA","DELEGATES_FROM_LIST","TOP_DELEGATES_OFFSET","ethers","fetchProfileData","isAddress","PRELOADED_PROPOSALS","AUTONOMOUS_PROPOSAL_BYTECODE","fetchGlobalData","client","query","fetchPolicy","then","res","id","data","governances","delegatedVotes","parseInt","delegatedVotesRaw","totalTokenHolders","totalDelegates","Promise","reject","catch","fetchDelegatesFromClient","library","allIdentities","typed","all","delegates","map","d","getCode","handles","a","checksummed","handle","twitter","undefined","profileData","e","account","imageURL","profile_image_url","i","EOA","autonomous","find","h","toLowerCase","message","fetchTopDelegates","fetchTopDelegatesOffset","maxFetched","variables","skip","fetchVerifiedDelegates","list","Object","keys","toLocaleLowerCase","enumerateProposalState","state","proposalStates","PROPOSAL_PROMISES","fetchProposals","key","govId","proposals","p","description","length","console","log","startBlock","replace","title","split","proposer","status","forCount","againstCount","endBlock","forVotes","againstVotes","details","targets","t","name","types","callData","signature","signatures","sigSplit","substr","calldata","calldatas","decoded","utils","defaultAbiCoder","decode","toString","target","functionSig"],"mappings":"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","sourcesContent":["import { Identities } from './../state/social/reducer'\nimport { Web3Provider } from '@ethersproject/providers'\nimport { TOP_DELEGATES, PROPOSALS, GLOBAL_DATA, DELEGATES_FROM_LIST, TOP_DELEGATES_OFFSET } from '../apollo/queries'\nimport { DelegateData, ProposalData } from '../state/governance/hooks'\nimport { ethers } from 'ethers'\nimport { fetchProfileData } from './social'\nimport { isAddress } from '../utils'\nimport { DocumentNode } from 'graphql'\nimport { PRELOADED_PROPOSALS } from '../constants'\nimport { GlobaData } from '../state/governance/reducer'\nimport { AUTONOMOUS_PROPOSAL_BYTECODE } from '../constants/proposals'\n\ninterface DelegateResponse {\n  data: {\n    delegates: DelegateData[]\n  }\n}\n\ninterface GlobalResponse {\n  data: {\n    governances: {\n      id: string\n      delegatedVotes: string\n      delegatedVotesRaw: string\n      totalTokenHolders: string\n      totalDelegates: string\n    }[]\n  }\n}\n\nexport async function fetchGlobalData(client: any): Promise<GlobaData | null> {\n  if (!client) {\n    return null\n  }\n  return client\n    .query({\n      query: GLOBAL_DATA,\n      fetchPolicy: 'cache-first',\n    })\n    .then(async (res: GlobalResponse) => {\n      if (res) {\n        return {\n          id: res.data.governances[0].id,\n          delegatedVotes: parseInt(res.data.governances[0].delegatedVotes),\n          delegatedVotesRaw: parseInt(res.data.governances[0].delegatedVotesRaw),\n          totalTokenHolders: parseInt(res.data.governances[0].totalTokenHolders),\n          totalDelegates: parseInt(res.data.governances[0].totalDelegates),\n        }\n      } else {\n        return Promise.reject('Error fetching global data')\n      }\n    })\n    .catch(() => {\n      return Promise.reject('Error fetching from subgraph')\n    })\n}\n\ninterface DelegateQuery {\n  query: DocumentNode\n  variables?: { list?: false | string[] | undefined; skip?: number | undefined }\n  fetchPolicy: string\n}\n\nasync function fetchDelegatesFromClient(\n  client: any,\n  library: Web3Provider,\n  allIdentities: Identities,\n  query: DelegateQuery\n): Promise<DelegateData[] | null> {\n  try {\n    return client\n      .query(query)\n      .then(async (res: DelegateResponse) => {\n        // check if account is EOA or not\n        const typed = await Promise.all(\n          res.data.delegates.map((d) => {\n            return library?.getCode(d.id)\n          })\n        )\n        // for each handle - get twitter profile data ,\n        const handles = await Promise.all(\n          res.data.delegates.map(async (a: DelegateData) => {\n            const checksummed = isAddress(a.id)\n            const handle = checksummed ? allIdentities?.[checksummed]?.twitter?.handle : undefined\n\n            let profileData\n            try {\n              if (handle) {\n                const res = await fetchProfileData(handle)\n                if (res) {\n                  profileData = res\n                }\n              }\n            } catch (e) {\n              profileData = undefined\n            }\n\n            return {\n              account: a.id,\n              handle,\n              imageURL: profileData?.data?.profile_image_url,\n            }\n          })\n        )\n\n        return res.data.delegates.map((d, i) => {\n          const checksummed = isAddress(d.id)\n          if (checksummed) {\n            d.id = checksummed\n          }\n\n          return {\n            ...d,\n            EOA: typed[i] === '0x',\n            autonomous: typed[i] === AUTONOMOUS_PROPOSAL_BYTECODE,\n            handle: handles.find((h) => h.account.toLowerCase() === d.id.toLowerCase())?.handle,\n            imageURL: handles.find((h) => h.account.toLowerCase() === d.id.toLowerCase())?.imageURL,\n          }\n        })\n      })\n      .catch((e: any) => {\n        return Promise.reject(`Error fetching delegates from subgraph: ${e.message}`)\n      })\n  } catch (e) {\n    return Promise.reject('Unable to fetch delegates')\n  }\n}\n\nexport async function fetchTopDelegates(\n  client: any,\n  library: Web3Provider,\n  allIdentities: Identities\n): Promise<DelegateData[] | null> {\n  return fetchDelegatesFromClient(client, library, allIdentities, {\n    query: TOP_DELEGATES,\n    fetchPolicy: 'cache-first',\n  })\n}\n\nexport async function fetchTopDelegatesOffset(\n  client: any,\n  library: Web3Provider,\n  allIdentities: Identities,\n  maxFetched: number\n): Promise<DelegateData[] | null> {\n  return fetchDelegatesFromClient(client, library, allIdentities, {\n    query: TOP_DELEGATES_OFFSET,\n    variables: {\n      skip: maxFetched,\n    },\n    fetchPolicy: 'cache-first',\n  })\n}\n\n/**\n * Used for filtering on verified entries only\n */\nexport async function fetchVerifiedDelegates(\n  client: any,\n  library: Web3Provider,\n  allIdentities: Identities\n): Promise<DelegateData[] | null> {\n  return fetchDelegatesFromClient(client, library, allIdentities, {\n    query: DELEGATES_FROM_LIST,\n    variables: {\n      // filter on address - graph needs lowercase\n      list: allIdentities && Object.keys(allIdentities)?.map((a) => a.toLocaleLowerCase()),\n    },\n    fetchPolicy: 'cache-first',\n  })\n}\n\n/**\n * @todo replace with auto generated grapql format\n */\ninterface ProposalResponse {\n  data: {\n    proposals: {\n      id: string\n      proposer: {\n        [id: string]: string\n      }\n      description: string\n      status: string | undefined\n      targets: string[]\n      values: string[]\n      signatures: string[]\n      calldatas: string[]\n      startBlock: string\n      endBlock: string\n      forVotes: {\n        support: boolean\n        votes: string\n        voter: {\n          id: string\n        }\n      }[]\n      againstVotes: {\n        support: boolean\n        votes: string\n        voter: {\n          id: string\n        }\n      }[]\n    }[]\n  }\n}\n\nexport const enumerateProposalState = (state: number) => {\n  const proposalStates = ['pending', 'active', 'canceled', 'defeated', 'succeeded', 'queued', 'expired', 'executed']\n  return proposalStates[state]\n}\n\n// @todo add typed query response\nconst PROPOSAL_PROMISES: { [key: string]: Promise<ProposalData[] | null> } = {}\n\nexport async function fetchProposals(client: any, key: string, govId: string): Promise<ProposalData[] | null> {\n  return (PROPOSAL_PROMISES[key] =\n    PROPOSAL_PROMISES[key] ??\n    client\n      .query({\n        query: PROPOSALS,\n        fetchPolicy: 'cache-first',\n      })\n      .then(async (res: ProposalResponse) => {\n        if (res) {\n          return res.data.proposals.map((p, i) => {\n            let description = PRELOADED_PROPOSALS[govId]?.[res.data.proposals.length - i - 1] || p.description\n            console.log(p.startBlock)\n            if (p.startBlock === '13551293') {\n              description = description.replace(/  /g, '\\n').replace(/\\d\\. /g, '\\n$&')\n            }\n\n            return {\n              id: p.id,\n              title: description?.split(/# |\\n/g)[1] || 'Untitled',\n              description: description || 'No description.',\n              proposer: p.proposer.id,\n              status: undefined, // initialize as 0\n              forCount: undefined, // initialize as 0\n              againstCount: undefined, // initialize as 0\n              startBlock: parseInt(p.startBlock),\n              endBlock: parseInt(p.endBlock),\n              forVotes: p.forVotes,\n              againstVotes: p.againstVotes,\n              details: p.targets.map((t, i) => {\n                let name = '',\n                  types = '',\n                  callData = ''\n                const signature = p.signatures[i]\n                if (signature) {\n                  const sigSplit = signature.substr(0, signature.length - 1).split('(')\n                  name = sigSplit[0]\n                  types = sigSplit[1]\n                }\n\n                const calldata = p.calldatas[i]\n                if (calldata && types) {\n                  const decoded = ethers.utils.defaultAbiCoder.decode(types.split(','), calldata)\n                  callData = decoded.toString()\n                }\n\n                return {\n                  target: p.targets[i],\n                  functionSig: name,\n                  callData,\n                }\n              }),\n            }\n          })\n        }\n        return null\n      })).catch(() => {\n    return Promise.reject('Error fetching proposals from subgraph')\n  })\n}\n"]},"metadata":{},"sourceType":"module"}